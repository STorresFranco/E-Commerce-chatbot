#%% Library importation
import chromadb
from chromadb.utils import embedding_functions
import dotenv
import pandas as pd
from groq import Groq
import os
import sys
sys.path.append(os.path.abspath("."))
from Backend.semantic_routing import rl

#%% Functions
def initializer():
    ''' 
    Description
        Function to initializce the persisnte client of chroma
    Inputs
        None
    Returns
        client (chromadb persisnte client)
    '''
    client=chromadb.PersistentClient(path="Backend/faq_vector_store")
    return client

def create_collection(client,collection_name):
    '''  
    Description
        Function to add documents to a chroma db collection contained in a chromadb client}
    Inputs
        client (chromadb client)
        collection_name (str): Name to assign to a collection
        emb_fun (chromadb embedding): Embedding function used to process collections 
        doc_path (str): Path from which documents are loaded
    '''

    #Get client collections 
    collections=[col.name for col in client.list_collections()] #To check if collection exist

    #Add collection if inexistent
    if collection_name not in collections:
        #Embedding function for chromadb
        emb_fun=embedding_functions.SentenceTransformerEmbeddingFunction(
        model_name="all-distilroberta-v1"
        )
       
        #Get the doc information
        doc_path="Backend/resources/faq_data.csv"
        doc_df=pd.read_csv(doc_path)            
        doc_question=doc_df.question.to_list()  

        #Retrieve Question and Answer fields from FAQ file
        doc_answer=doc_df.answer.to_list()       
        doc_metadata=[{"answer":answer} for answer in doc_answer]

        #Populate collection
        collection=client.get_or_create_collection(name=collection_name,embedding_function=emb_fun)
        collection.add(
            documents=doc_question,
            metadatas=doc_metadata,
            ids=[f"faq-{id}" for id in range(len(doc_df))]
        )
        print("Data ingested") #Checkpoint
        return collection
    else:
        print(f"Collection {collection_name} already existed")

def get_relevant_info(client,collection_name,query):
    ''' 
    Description
        Function to retrieve relevant info from chromadb using sementic similarity
    Inputs
        collection_name (str): Name of the string from which information is retrieved
        query (str): Query passed by user
    Returns
        results (dic): Dictionary with top 2 results
    '''
    #Get the collection
    collection=client.get_collection(collection_name)
    
    #Query results
    results=collection.query(
        query_texts=[query],
        n_results=2
    )
    return results


def generate_answer(query,context):
    ''' 
    Description:
        Function to get an answer from the chatbot based on a context and a query
    Inputs
        query (str): Query passed by the user
        context (str): Context passed by the user
    '''
    template=f'''
            Given the following question and context below generate an answer. If you dont know the answer simply say you don't know. Don't make up answers

            Question {query}

            Context: {context}
            
            '''

    client = Groq(
        # This is the default and can be omitted
        api_key=GROQ_KEY,
    )

    chat_completion = client.chat.completions.create(
        messages=[
            {
                "role": "user",
                "content": template,
            }
        ],
        model=GROQ_MODEL, # type: ignore
    )
    return chat_completion.choices[0].message.content

def faq_chain(client,query,collection_name):
    ''' 
    Description
        Function Pipeline-like to retrieve an answer from chatbot using relevant information as context
    Inputs
        client (chromadb persistent client)
        query (str): Query generated by the user
        collection_name (str): Collection name on which to perform query
    Returns
        answer (str): String generated by the chatbot
    '''
    results=get_relevant_info(client,collection_name,query)
    context="\n".join([result.get("answer") for result in results["metadatas"][0]]) #type: ignore
    answer=generate_answer(query,context)

    return answer

if __name__=="__main__":

    print(rl.router("What is the return policy of the products?").name)

